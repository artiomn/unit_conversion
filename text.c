/*
	text.c
*/

#include <stdio.h>
#include "functions.h"

//
// Функции ввода
//

double get_text(const char *c) {
	return((double) (int) c);
}

//
// Функции преобразования
//

typedef struct tl_s {
	char fr[3];
	char to[3];
} tstruc;

double tlit_re(double ptr) {
	static tstruc cnv_re[] = {
		{"й", "y"}, {"ц", "c"}, {"у", "u"}, {"к", "k"}, {"е", "e"}, {"н", "n"}, {"г", "g"}, \
		{"ш", "sh"}, {"щ", "sh"}, {"з", "z"}, {"х", "h"}, {"ъ", "'"}, {"ф", "f"}, \
		{"ы", "i"}, {"в", "v"}, {"а", "a"}, {"п", "p"}, {"р", "r"}, {"о", "o"}, {"л", "l"}, \
		{"д", "d"}, {"ж", "j"}, {"э", "e"}, {"я", "ya"}, {"ч", "ch"}, {"с", "s"}, \
		{"м", "m"}, {"и", "i"}, {"т", "t"}, {"ь", "'"}, {"б", "b"}, {"ю", "iu"}, \
		{"ё", "io"}, {"ку", "q"}, {"кс", "x"}, \
		{"Й", "Y"}, {"Ц", "C"}, {"У", "U"}, {"К", "K"}, {"Е", "E"}, {"Н", "N"}, {"Г", "G"}, \
		{"Ш", "SH"}, {"Щ", "SH"}, {"З", "Z"}, {"Х", "H"}, {"Ъ", "'"}, {"Ф", "F"}, \
		{"Ы", "I"}, {"В", "V"}, {"А", "A"}, {"П", "P"}, {"Р", "R"}, {"О", "O"}, {"Л", "L"}, \
		{"Д", "D"}, {"Ж", "J"}, {"Э", "E"}, {"Я", "Ya"}, {"Ч", "Ch"}, {"С", "S"}, \
		{"М", "M"}, {"И", "I"}, {"Т", "T"}, {"Ь", "'"}, {"Б", "B"}, {"Ю", "Iu"}, \
		{"Ё", "Io"}, {"КУ", "Q"}, {"Ку", "Q"}, {"КС", "X"}, {"Кс", "X"}, \
		{ "\0" } \
	};
	double tlit(double, tstruc*);
	ptr = tlit(ptr, cnv_re);
	return(ptr);
}

double tlit_er(double ptr) {
	static tstruc cnv_er[] = {
		{"q", "ку"}, {"w", "в"}, {"e", "е"}, {"r", "р"}, {"t", "т"}, \
		{"y", "й"}, {"u", "у"}, {"i", "и"}, {"o", "о"}, {"p", "п"}, {"a", "а"}, \
		{"s", "с"}, {"d", "д"}, {"f", "ф"}, {"g", "г"}, {"h", "х"}, {"j", "ж"}, \
		{"k", "к"}, {"l", "л"}, {"z", "з"}, {"x", "кс"}, {"c", "ц"}, {"v", "в"}, \
		{"b", "б"}, {"n", "н"}, {"m", "м"}, {"qu", "ку"}, {"yu", "ю"}, {"yo", "ё"}, \
		{"ya", "я"}, {"iu", "ю"}, {"io", "ё"}, {"ia", "я"}, {"sh", "ш"}, {"ch", "ч"}, \
		{"Q", "КУ"}, {"W", "В"}, {"E", "Е"}, {"R", "Р"}, {"T", "Т"}, \
		{"Y", "Й"}, {"U", "У"}, {"I", "И"}, {"O", "О"}, {"P", "П"}, {"A", "А"}, \
		{"S", "С"}, {"D", "Д"}, {"F", "Ф"}, {"G", "Г"}, {"H", "Х"}, {"J", "Ж"}, \
		{"K", "К"}, {"L", "Л"}, {"Z", "З"}, {"X", "КС"}, {"C", "Ц"}, {"V", "В"}, \
		{"B", "Б"}, {"N", "Н"}, {"M", "М"}, {"QU", "КУ"}, {"Qu", "КУ"}, {"YU", "Ю"}, \
		{"Yu", "Ю"}, {"YO", "Ё"}, {"Yo", "Ё"}, {"YA", "Я"}, {"Ya", "Я"}, {"IU", "Ю"}, \
		{"Iu", "Ю"}, {"IO", "Ё"}, {"Io", "Ё"}, {"IA", "Я"}, {"Ia", "Я"}, {"SH", "Ш"}, \
		{"Sh", "Ш"}, {"CH", "Ч"}, {"Ch", "Ч"}, \
		{ "\0" } \
	};
	double tlit(double, tstruc*);
	ptr = tlit(ptr, cnv_er);
	return(ptr);
}

//
// Функции вывода
//

void out_text(double ptr) {	
	printf("%s%s", (char*) (int) ptr, NL_SYM);
}

//
// Служебные функции
//

double tlit(double ptr, tstruc* cnv_arr) {
// Функция-преобразователь
	char c[3];
	char *str = (char*) (int) ptr, *new_str;
	size_t sz = 0;
	FILE* f = (FILE*) open_memstream(&new_str, &sz);
	register int i = 0, j, flag; // flag = 0 - Найдено соответствие
	while ((c[0] = str[i++]) != '\0') {
		j = 0, flag = 1;
		c[1] = str[i], // Если последний символ, то 0
		c[2] = '\0';
		while ((cnv_arr[j].fr[0] != (char) NULL) && flag) {
			// Ищу соответствие двум символам
			flag = strcmp(c, cnv_arr[j++].fr);
		}

		if (flag) {
			// Не нашёл
			j = 0, c[1] = '\0', i--; // В следующем цикле обрабатываю символ бывший 2-м
			while ((cnv_arr[j].fr[0] != '\0') && flag) {
				// Ищу соответствие одному символу
				flag = strcmp(c, cnv_arr[j++].fr);
			}
		}

		if (flag) {
			// Не нашёл соответствий
			fputc(c[0], f);	// Кидаю символ из строки
		}
		else {
			// Нашёл соответствие
			fputs(cnv_arr[--j].to, f);	// Перевожу
		}		
		if (str[i++] == '\0') break; 	// Переход на следующий символ/пару
						// break - чтобы не пропустить '\0' символ
	}
	fputc('\0', f);
	fflush(f);
	fclose(f);
//	free(str);
	return((double) (int) new_str);
}

/* EOF */

